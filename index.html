<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Momo Christmas Tree</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&family=Pinyon+Script&display=swap" rel="stylesheet">
    
    <!-- Babel Standalone for in-browser JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Styles -->
    <style>
      body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000504; }
      .font-display { font-family: 'Cinzel', serif; }
      .font-body { font-family: 'Playfair Display', serif; }
      .font-script { font-family: 'Pinyon Script', cursive; }

      /* Streaming Gold Text Effect */
      .gold-shine {
        background: linear-gradient(
          110deg,
          #8a6000 10%, 
          #e6c200 25%, 
          #fffbc4 35%, 
          #e6c200 45%, 
          #8a6000 60%, 
          #e6c200 75%, 
          #fffbc4 85%, 
          #e6c200 90%
        );
        background-size: 200% auto;
        color: transparent;
        -webkit-background-clip: text;
        background-clip: text;
        animation: shine 5s linear infinite;
      }

      @keyframes shine {
        to {
          background-position: 200% center;
        }
      }
    </style>

    <!-- Import Map: Explicitly pinning React 18.2.0 to avoid conflicts with v19 -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.14?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
    "uuid": "https://esm.sh/uuid@9.0.1",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>

    <!-- Main Application Code -->
    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useLayoutEffect } from 'react';
        import ReactDOM from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame, useThree } from '@react-three/fiber';
        import { PerspectiveCamera, Environment, OrbitControls } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

        // --- types.ts ---
        const TreeState = {
            SCATTERED: 'SCATTERED',
            TREE_SHAPE: 'TREE_SHAPE'
        };

        const COLORS = {
            EMERALD_DEEP: "#00241B",
            EMERALD_LITE: "#0B4F3C",
            GOLD_METALLIC: "#D4AF37",
            GOLD_ROSE: "#E6C288",
            WHITE_WARM: "#FFFDD0",
            RED_VELVET: "#4a0404"
        };

        // --- shaders.ts ---
        const foliageVertexShader = `
            uniform float uTime;
            uniform float uMorphProgress; // 0.0 = Scattered, 1.0 = Tree
            uniform float uPixelRatio;

            attribute vec3 aScatterPos;
            attribute vec3 aTreePos;
            attribute float aRandom;
            attribute float aSize;
            attribute vec3 aColor;

            varying vec3 vColor;
            varying float vAlpha;
            varying float vIsGold;
            varying float vRandom;

            // Cubic easing for smooth movement
            float easeInOutCubic(float t) {
                return t < 0.5 ? 4.0 * t * t * t : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;
            }

            void main() {
                vColor = aColor;
                vRandom = aRandom;
                // Simple heuristic to detect if this is a gold sparkle or green leaf based on redness
                vIsGold = step(0.5, aColor.r); 

                // Add individual offset to morph progress for organic feel
                float localProgress = clamp((uMorphProgress - aRandom * 0.2) / 0.8, 0.0, 1.0);
                float easedProgress = easeInOutCubic(localProgress);

                // Interpolate position
                vec3 newPos = mix(aScatterPos, aTreePos, easedProgress);

                // --- ENHANCED BREATHING ---
                float breath = sin(uTime * 2.0 + aRandom * 15.0) * 0.15;
                
                // Apply breathing mostly when formed as a tree
                if (uMorphProgress > 0.5) {
                    vec3 breathDir = normalize(vec3(newPos.x, 0.0, newPos.z)); 
                    newPos += breathDir * breath * easedProgress;
                }

                // --- FLOATING (SCATTERED) ---
                float floatAnim = sin(uTime * 0.5 + aRandom * 20.0) * 0.5;
                if (uMorphProgress < 0.5) {
                    newPos.y += floatAnim * (1.0 - easedProgress);
                }

                vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // --- TWINKLE SIZE ---
                // Make particles pulsate in size slightly
                float twinkle = 1.0 + sin(uTime * 3.0 + aRandom * 100.0) * 0.2; 

                // Size attenuation
                gl_PointSize = aSize * twinkle * uPixelRatio * (25.0 / -mvPosition.z);
                
                // Fade out particles slightly when they are far back
                vAlpha = smoothstep(60.0, 10.0, -mvPosition.z);
            }
        `;

        const foliageFragmentShader = `
            uniform float uTime;
            
            varying vec3 vColor;
            varying float vAlpha;
            varying float vIsGold;
            varying float vRandom;

            void main() {
                // Coordinate from 0.0 to 1.0 (center at 0.5, 0.5)
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                
                if (dist > 0.5) discard;

                // --- SOFT SHAPE ---
                // Gaussian-like falloff for a glowing point look
                // 0.0 at center -> 1.0 at edge
                float glow = 1.0 - (dist * 2.0);
                glow = pow(glow, 2.0); // Smooth bell curve

                // --- STAR SHINE ANIMATION ---
                // Instead of a static rim, we make the whole particle pulse brightness
                // Frequency varies per particle
                float shineSpeed = 2.0 + vRandom * 4.0;
                float shinePhase = uTime * shineSpeed + vRandom * 100.0;
                
                // Base shine factor
                float shine = 0.8 + 0.4 * sin(shinePhase); 
                
                // Boost brightness for gold sparkles significantly
                if (vIsGold > 0.5) {
                    shine = 1.5 + 1.5 * sin(shinePhase * 1.5); // Rapid high contrast sparkle
                    // Hot center for gold
                    if (dist < 0.15) shine += 3.0;
                } else {
                    // For green particles:
                    // No white rim. 
                    // Just a subtle "alive" shimmer in intensity to show depth.
                    shine = 0.9 + 0.3 * sin(shinePhase);
                }

                // Apply shine to color
                vec3 finalColor = vColor * shine;

                // Final alpha composition
                gl_FragColor = vec4(finalColor, vAlpha * glow);
            }
        `;

        // --- components/AmbientParticles.tsx ---
        const snowVertexShader = `
            uniform float uTime;
            uniform float uHeight;
            uniform float uSpeed;
            uniform float uPixelRatio;
            
            attribute float aRandom;
            attribute float aSize;
            
            varying float vAlpha;
            varying float vRandom;

            void main() {
                vRandom = aRandom;
                vec3 pos = position;
                
                // Falling animation
                float fallDistance = uTime * (uSpeed + aRandom * 1.5); 
                
                // Wrap height logic
                float height = uHeight;
                // Offset by height/2 to center the wrap range around 0
                pos.y = mod(position.y - fallDistance + height * 0.5, height) - height * 0.5;
                
                // Complex Wind/Sway
                // Combine two sine waves for more organic motion
                float swayTime = uTime * 0.5 + aRandom * 100.0;
                float swayAmp = 0.5 + aRandom * 0.5; 
                
                pos.x += sin(swayTime) * swayAmp + sin(swayTime * 3.0) * 0.2;
                pos.z += cos(swayTime * 0.8) * swayAmp + cos(swayTime * 2.5) * 0.2;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
                
                // Size attenuation with Pixel Ratio support for crisp rendering on all devices
                gl_PointSize = aSize * uPixelRatio * (40.0 / -mvPosition.z);
                
                // Alpha Logic (Fade edges)
                float edgeThreshold = 8.0;
                float alphaTop = smoothstep(height * 0.5, height * 0.5 - edgeThreshold, pos.y);
                float alphaBottom = smoothstep(-height * 0.5, -height * 0.5 + edgeThreshold, pos.y);
                
                // Twinkle/Breath
                float twinkle = 0.8 + 0.2 * sin(uTime * 2.0 + aRandom * 50.0);
                
                vAlpha = 0.8 * alphaTop * alphaBottom * twinkle;
            }
        `;

        const snowFragmentShader = `
            varying float vAlpha;
            varying float vRandom;
            
            void main() {
                // Soft circle shape
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                
                if (dist > 0.5) discard;
                
                // Radial gradient for fluffy look
                float strength = 1.0 - (dist * 2.0);
                strength = pow(strength, 2.0); // Soft falloff
                
                // Silver / White Gloss Colors
                // vRandom splits them into slightly different tones of white/silver
                vec3 cWhite = vec3(1.0, 1.0, 1.0);
                vec3 cSilver = vec3(0.85, 0.90, 0.95); // Cool blue-ish silver
                
                vec3 finalColor = mix(cSilver, cWhite, step(0.5, vRandom));
                
                // Boost brightness for "Gloss/Bloom" effect
                finalColor *= 2.0;
                
                gl_FragColor = vec4(finalColor, vAlpha * strength);
            }
        `;

        const AmbientParticles = () => {
            const count = 5000;
            const meshRef = useRef(null);
            
            const uniforms = useMemo(() => ({
                uTime: { value: 0 },
                uHeight: { value: 60.0 },
                uSpeed: { value: 2.0 },
                uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
            }), []);

            const { positions, randoms, sizes } = useMemo(() => {
                const pos = new Float32Array(count * 3);
                const rnd = new Float32Array(count);
                const siz = new Float32Array(count);
                
                const rangeXZ = 60;
                const rangeY = 60; 
                
                for (let i = 0; i < count; i++) {
                    pos[i * 3] = (Math.random() - 0.5) * rangeXZ;
                    pos[i * 3 + 1] = (Math.random() - 0.5) * rangeY;
                    pos[i * 3 + 2] = (Math.random() - 0.5) * rangeXZ;
                    
                    rnd[i] = Math.random();
                    siz[i] = 1.5 + Math.random() * 3.5; 
                }
                
                return { positions: pos, randoms: rnd, sizes: siz };
            }, []);

            useFrame((state) => {
                if (meshRef.current) {
                    const material = meshRef.current.material;
                    material.uniforms.uTime.value = state.clock.getElapsedTime();
                }
            });

            return (
                <points ref={meshRef}>
                <bufferGeometry>
                    <bufferAttribute attach="attributes-position" count={count} array={positions} itemSize={3} />
                    <bufferAttribute attach="attributes-aRandom" count={count} array={randoms} itemSize={1} />
                    <bufferAttribute attach="attributes-aSize" count={count} array={sizes} itemSize={1} />
                </bufferGeometry>
                <shaderMaterial 
                    vertexShader={snowVertexShader}
                    fragmentShader={snowFragmentShader}
                    uniforms={uniforms}
                    transparent={true}
                    depthWrite={false}
                    blending={THREE.AdditiveBlending}
                />
                </points>
            );
        };

        // --- components/Foliage.tsx ---
        const Foliage = ({ progress }) => {
            const count = 75000; 
            const meshRef = useRef(null);
            const { viewport } = useThree();

            const uniforms = useMemo(() => ({
                uTime: { value: 0 },
                uMorphProgress: { value: 0 },
                uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) },
            }), []);

            const { positions, scatterPositions, treePositions, colors, randoms, sizes } = useMemo(() => {
                const pos = new Float32Array(count * 3);
                const scatterPos = new Float32Array(count * 3);
                const treePos = new Float32Array(count * 3);
                const col = new Float32Array(count * 3);
                const rnd = new Float32Array(count);
                const siz = new Float32Array(count);

                const colorEmerald = new THREE.Color("#004d3d");
                const colorLite = new THREE.Color("#107a5d");
                const colorGold = new THREE.Color(COLORS.GOLD_METALLIC);

                for (let i = 0; i < count; i++) {
                    pos[i * 3] = 0; pos[i * 3 + 1] = 0; pos[i * 3 + 2] = 0;

                    const rScatter = 18 + Math.random() * 15;
                    const thetaScatter = Math.random() * Math.PI * 2;
                    const phiScatter = Math.acos(2 * Math.random() - 1);
                    
                    scatterPos[i * 3] = rScatter * Math.sin(phiScatter) * Math.cos(thetaScatter);
                    scatterPos[i * 3 + 1] = rScatter * Math.sin(phiScatter) * Math.sin(thetaScatter);
                    scatterPos[i * 3 + 2] = rScatter * Math.cos(phiScatter);

                    const h = 18; 
                    const y = Math.random() * h; 
                    const rBase = 7.0;
                    const radiusAtY = (1 - (y / h)) * rBase; 
                    
                    const r = Math.sqrt(Math.random()) * radiusAtY; 
                    const theta = Math.random() * Math.PI * 2;

                    treePos[i * 3] = r * Math.cos(theta);
                    treePos[i * 3 + 1] = y - (h/2); 
                    treePos[i * 3 + 2] = r * Math.sin(theta);

                    const mixFactor = Math.random();
                    let c = new THREE.Color();
                    let s = 1.0;

                    if (mixFactor > 0.92) {
                        c.copy(colorGold).multiplyScalar(1.5); 
                        s = 3.0 + Math.random() * 2.0; 
                    } else {
                        c.lerpColors(colorEmerald, colorLite, Math.random());
                        c.multiplyScalar(0.8 + Math.random() * 0.5); 
                        s = 2.0 + Math.random() * 2.5; 
                    }

                    col[i * 3] = c.r;
                    col[i * 3 + 1] = c.g;
                    col[i * 3 + 2] = c.b;

                    siz[i] = s;
                    rnd[i] = Math.random();
                }

                return {
                    positions: pos,
                    scatterPositions: scatterPos,
                    treePositions: treePos,
                    colors: col,
                    randoms: rnd,
                    sizes: siz
                };
            }, []);

            useFrame((state) => {
                if (meshRef.current) {
                    const material = meshRef.current.material;
                    material.uniforms.uTime.value = state.clock.getElapsedTime();
                    
                    material.uniforms.uMorphProgress.value = THREE.MathUtils.lerp(
                        material.uniforms.uMorphProgress.value,
                        progress,
                        0.08
                    );
                    
                    if (progress > 0.8) {
                        meshRef.current.rotation.y += 0.002;
                    }
                }
            });

            return (
                <points ref={meshRef}>
                <bufferGeometry>
                    <bufferAttribute attach="attributes-position" count={count} array={positions} itemSize={3} />
                    <bufferAttribute attach="attributes-aScatterPos" count={count} array={scatterPositions} itemSize={3} />
                    <bufferAttribute attach="attributes-aTreePos" count={count} array={treePositions} itemSize={3} />
                    <bufferAttribute attach="attributes-aColor" count={count} array={colors} itemSize={3} />
                    <bufferAttribute attach="attributes-aRandom" count={count} array={randoms} itemSize={1} />
                    <bufferAttribute attach="attributes-aSize" count={count} array={sizes} itemSize={1} />
                </bufferGeometry>
                <shaderMaterial
                    vertexShader={foliageVertexShader}
                    fragmentShader={foliageFragmentShader}
                    uniforms={uniforms}
                    transparent={true}
                    depthWrite={false}
                    blending={THREE.NormalBlending} 
                />
                </points>
            );
        };

        // --- components/GoldenSpirals.tsx ---
        const spiralVertexShader = `
            uniform float uTime;
            uniform float uMorphProgress;
            uniform float uPixelRatio;

            attribute vec3 aScatterPos;
            attribute vec3 aTreePos;
            attribute float aProgress; // 0.0 (bottom) to 1.0 (top) along the spiral
            attribute float aSize;
            attribute float aRandom;

            varying float vAlpha;
            varying float vProgress;

            // Cubic easing
            float easeInOutCubic(float t) {
                return t < 0.5 ? 4.0 * t * t * t : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;
            }

            void main() {
                vProgress = aProgress;
                
                // Morph Logic
                float localProgress = clamp((uMorphProgress - aRandom * 0.1) / 0.9, 0.0, 1.0);
                float easedProgress = easeInOutCubic(localProgress);

                vec3 pos = mix(aScatterPos, aTreePos, easedProgress);

                // --- SPIRAL ANIMATION ---
                // When formed, add a subtle breathing/tightening effect
                if (uMorphProgress > 0.5) {
                float breath = sin(uTime * 1.5) * 0.05;
                pos.x *= (1.0 + breath);
                pos.z *= (1.0 + breath);
                }

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;

                // --- FLOWING SIZE EFFECT ---
                // Create a "pulse" that travels up the ribbon
                // Frequency: 15.0, Speed: 3.0
                float flow = sin(aProgress * 15.0 - uTime * 4.0);
                float sizePulse = 1.0 + flow * 0.4;
                
                // Twinkle randomly
                float twinkle = 1.0 + sin(uTime * 5.0 + aRandom * 100.0) * 0.3;

                gl_PointSize = aSize * sizePulse * twinkle * uPixelRatio * (50.0 / -mvPosition.z);
                
                // Fade out slightly at the very top of the spiral
                vAlpha = smoothstep(1.0, 0.8, aProgress);
            }
        `;

        const spiralFragmentShader = `
            uniform float uTime;
            varying float vAlpha;
            varying float vProgress;

            void main() {
                vec2 coord = gl_PointCoord - vec2(0.5);
                float dist = length(coord);
                if (dist > 0.5) discard;

                // Harder core, softer glow
                float glow = 1.0 - (dist * 2.0);
                glow = pow(glow, 1.5);

                // --- GOLD COLOR PALETTE ---
                // Base Gold
                vec3 colorA = vec3(1.0, 0.7, 0.1); 
                // Highlight Gold (White-ish)
                vec3 colorB = vec3(1.0, 0.95, 0.8);
                
                // Flowing highlight logic matching vertex shader
                float flow = sin(vProgress * 15.0 - uTime * 4.0);
                
                // Mix colors based on flow to create bright bands
                vec3 finalColor = mix(colorA, colorB, smoothstep(0.0, 1.0, flow));
                
                // Extra brightness boost
                finalColor *= 1.5;

                gl_FragColor = vec4(finalColor, vAlpha * glow);
            }
        `;

        const GoldenSpirals = ({ progress }) => {
            const particlesPerRibbon = 2000;
            const ribbonCount = 2;
            const totalCount = particlesPerRibbon * ribbonCount;
            
            const meshRef = useRef(null);

            const uniforms = useMemo(() => ({
                uTime: { value: 0 },
                uMorphProgress: { value: 0 },
                uPixelRatio: { value: Math.min(window.devicePixelRatio, 2) }
            }), []);

            const { positions, scatterPositions, treePositions, sizes, progressArray, randoms } = useMemo(() => {
                const pos = new Float32Array(totalCount * 3);
                const scatterPos = new Float32Array(totalCount * 3);
                const treePos = new Float32Array(totalCount * 3);
                const siz = new Float32Array(totalCount);
                const prog = new Float32Array(totalCount);
                const rnd = new Float32Array(totalCount);

                const height = 18;
                const baseRadius = 8.0; 
                const rotations = 3.5;

                let idx = 0;

                for (let r = 0; r < ribbonCount; r++) {
                    const ribbonOffsetAngle = (r * Math.PI * 2) / ribbonCount;

                    for (let i = 0; i < particlesPerRibbon; i++) {
                        const t = i / particlesPerRibbon;

                        const y = (t * height) - (height / 2);
                        const radius = (1 - t) * baseRadius;
                        const angle = (t * rotations * Math.PI * 2) + ribbonOffsetAngle;

                        const widthRandom = (Math.random() - 0.5) * 0.6; 
                        const currentR = radius + widthRandom;

                        treePos[idx * 3] = currentR * Math.cos(angle);
                        treePos[idx * 3 + 1] = y;
                        treePos[idx * 3 + 2] = currentR * Math.sin(angle);

                        const rScatter = 20 + Math.random() * 10;
                        const thetaScatter = Math.random() * Math.PI * 2;
                        const phiScatter = Math.acos(2 * Math.random() - 1);
                        
                        scatterPos[idx * 3] = rScatter * Math.sin(phiScatter) * Math.cos(thetaScatter);
                        scatterPos[idx * 3 + 1] = rScatter * Math.sin(phiScatter) * Math.sin(thetaScatter);
                        scatterPos[idx * 3 + 2] = rScatter * Math.cos(phiScatter);

                        pos[idx * 3] = 0; pos[idx * 3 + 1] = 0; pos[idx * 3 + 2] = 0;

                        siz[idx] = 2.0 + Math.random() * 2.0; 
                        prog[idx] = t;
                        rnd[idx] = Math.random();

                        idx++;
                    }
                }

                return {
                    positions: pos,
                    scatterPositions: scatterPos,
                    treePositions: treePos,
                    sizes: siz,
                    progressArray: prog,
                    randoms: rnd
                };
            }, []);

            useFrame((state) => {
                if (meshRef.current) {
                    const material = meshRef.current.material;
                    material.uniforms.uTime.value = state.clock.getElapsedTime();
                    material.uniforms.uMorphProgress.value = THREE.MathUtils.lerp(
                        material.uniforms.uMorphProgress.value,
                        progress,
                        0.1
                    );
                    
                    if (progress > 0.8) {
                        meshRef.current.rotation.y += 0.003;
                    }
                }
            });

            return (
                <points ref={meshRef}>
                <bufferGeometry>
                    <bufferAttribute attach="attributes-position" count={totalCount} array={positions} itemSize={3} />
                    <bufferAttribute attach="attributes-aScatterPos" count={totalCount} array={scatterPositions} itemSize={3} />
                    <bufferAttribute attach="attributes-aTreePos" count={totalCount} array={treePositions} itemSize={3} />
                    <bufferAttribute attach="attributes-aSize" count={totalCount} array={sizes} itemSize={1} />
                    <bufferAttribute attach="attributes-aProgress" count={totalCount} array={progressArray} itemSize={1} />
                    <bufferAttribute attach="attributes-aRandom" count={totalCount} array={randoms} itemSize={1} />
                </bufferGeometry>
                <shaderMaterial 
                    vertexShader={spiralVertexShader}
                    fragmentShader={spiralFragmentShader}
                    uniforms={uniforms}
                    transparent={true}
                    depthWrite={false}
                    blending={THREE.AdditiveBlending}
                />
                </points>
            );
        };

        // --- components/Ornaments.tsx ---
        const Ornaments = ({ progress }) => {
            const baubleCount = 120; 
            const starCount = 1200;  
            
            const heavyBoxCount = 20;
            const heavySphereCount = 25; 
            const heavyGemCount = 20;

            const baubleRef = useRef(null);
            const starRef = useRef(null);
            
            const heavyBoxRef = useRef(null);
            const heavySphereRef = useRef(null);
            const heavyGemRef = useRef(null);

            const tempObj = useMemo(() => new THREE.Object3D(), []);
            const tempPos = useMemo(() => new THREE.Vector3(), []);
            
            const generateData = (count, type) => {
                const data = [];
                const height = 16;
                const baseRadius = 6.5;

                const cVividRed = new THREE.Color("#ff0040"); 
                const cVividGold = new THREE.Color("#ffcc00"); 
                const cVividGreen = new THREE.Color("#00dd66"); 
                const cVividBlue = new THREE.Color("#0066ff"); 
                const cVividWhite = new THREE.Color("#ffffff");
                
                const cWhite = new THREE.Color(COLORS.WHITE_WARM).multiplyScalar(2.0); 

                const isHeavy = type.startsWith('heavy');

                for (let i = 0; i < count; i++) {
                    let rS, yBias;
                    
                    if (isHeavy) {
                        rS = 8 + Math.random() * 10;
                        yBias = -5; 
                    } else if (type === 'star') {
                        rS = 25 + Math.random() * 25;
                        yBias = 12; 
                    } else {
                        rS = 12 + Math.random() * 15;
                        yBias = 0;
                    }

                    const thetaS = Math.random() * Math.PI * 2;
                    const phiS = Math.acos(2 * Math.random() - 1);
                    
                    const scatterPos = new THREE.Vector3(
                        rS * Math.sin(phiS) * Math.cos(thetaS),
                        rS * Math.sin(phiS) * Math.sin(thetaS) + yBias,
                        rS * Math.cos(phiS)
                    );

                    let yT, rT, thetaT;
                    if (isHeavy) {
                        yT = (Math.random() * 6) - 8; 
                        rT = (Math.random() * 4) + 2.0; 
                    } else {
                        yT = (Math.random() * height) - (height/2);
                        const nh = (yT + (height/2)) / height;
                        const coneR = (1 - nh) * baseRadius;
                        const offset = type === 'star' ? (0.2 + Math.random() * 2.0) : (Math.random() * 0.5);
                        rT = coneR + offset;
                    }
                    
                    thetaT = Math.random() * Math.PI * 2;
                    const treePos = new THREE.Vector3(rT * Math.cos(thetaT), yT, rT * Math.sin(thetaT));

                    let scale, weight;
                    if (isHeavy) {
                        weight = 0.8 + Math.random() * 0.2; 
                        
                        if (type === 'heavySphere') {
                            scale = 0.2 + Math.random() * 0.2; 
                        } else {
                            scale = 0.35 + Math.random() * 0.3; 
                        }

                    } else if (type === 'star') {
                        scale = 0.05 + Math.random() * 0.08; 
                        weight = 0.02 + Math.random() * 0.1; 
                    } else {
                        scale = 0.2 + Math.random() * 0.25; 
                        weight = 0.4 + Math.random() * 0.3; 
                    }

                    let color = new THREE.Color();
                    const roll = Math.random();

                    if (isHeavy) {
                        if (type === 'heavyGem') {
                            if (roll < 0.3) color.copy(cVividGreen).multiplyScalar(1.2);
                            else if (roll < 0.6) color.copy(cVividRed).multiplyScalar(1.2);
                            else color.copy(cVividWhite);
                        } else {
                            if (roll < 0.35) color.copy(cVividRed);
                            else if (roll < 0.60) color.copy(cVividGold);
                            else if (roll < 0.85) color.copy(cVividGreen);
                            else color.copy(cVividBlue);
                        }
                    } else if (type === 'bauble') {
                        if (roll < 0.45) color.copy(cVividGold);
                        else if (roll < 0.75) color.copy(cVividRed);
                        else color.copy(cVividGreen);
                        color.multiplyScalar(1.2); 
                    } else {
                        if (roll < 0.8) color.copy(cWhite);
                        else color.copy(cVividGold);
                    }

                    data.push({ 
                        scatterPos, 
                        treePos, 
                        scale, 
                        color, 
                        weight, 
                        randomRotation: [Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI] 
                    });
                }
                return data;
            };

            const baubles = useMemo(() => generateData(baubleCount, 'bauble'), []);
            const stars = useMemo(() => generateData(starCount, 'star'), []);
            
            const heavyBoxes = useMemo(() => generateData(heavyBoxCount, 'heavyBox'), []);
            const heavySpheres = useMemo(() => generateData(heavySphereCount, 'heavySphere'), []);
            const heavyGems = useMemo(() => generateData(heavyGemCount, 'heavyGem'), []);

            useFrame((state) => {
                const time = state.clock.getElapsedTime();

                const animateGroup = (ref, dataSet, type) => {
                    if (!ref.current) return;
                    const isHeavy = type.startsWith('heavy');

                    for (let i = 0; i < dataSet.length; i++) {
                        const data = dataSet[i];
                        
                        const ease = (t) => t<.5 ? 2*t*t : -1+(4-2*t)*t;
                        const t = ease(progress);

                        tempPos.lerpVectors(data.scatterPos, data.treePos, t);

                        if (progress < 0.98 || type === 'star') {
                            const floatAmp = (1.0 - data.weight) * (progress < 0.98 ? 1.5 : 0.1); 
                            const floatFreq = 0.5 + (1.0 - data.weight); 
                            
                            tempPos.y += Math.sin(time * floatFreq + i) * floatAmp * (1 - progress * 0.9);
                            
                            if (type === 'star') {
                                const drift = Math.cos(time * 0.3 + i) * floatAmp * 0.5 * (1 - progress);
                                tempPos.x += drift;
                                tempPos.z += Math.sin(time * 0.3 + i) * floatAmp * 0.5 * (1 - progress);
                            }
                        }

                        if (isHeavy && progress > 0.8) {
                            tempObj.rotation.set(0, data.randomRotation[1], 0);
                        } else {
                            tempObj.rotation.set(
                                data.randomRotation[0] + time * (0.2 / (data.weight + 0.1)),
                                data.randomRotation[1] + time * (0.1 / (data.weight + 0.1)),
                                data.randomRotation[2]
                            );
                        }

                        let s = data.scale;
                        if (type === 'star') {
                            const twinkle = Math.sin(time * 3.0 + i * 10.0);
                            s *= (0.8 + 0.5 * twinkle); 
                        } else {
                            s *= (0.9 + 0.1 * Math.sin(time + i));
                        }
                        tempObj.scale.setScalar(s);

                        tempObj.position.copy(tempPos);
                        tempObj.updateMatrix();
                        ref.current.setMatrixAt(i, tempObj.matrix);
                    }

                    ref.current.instanceMatrix.needsUpdate = true;
                    if (progress > 0.8) ref.current.rotation.y += 0.001;
                };

                animateGroup(baubleRef, baubles, 'bauble');
                animateGroup(starRef, stars, 'star');
                animateGroup(heavyBoxRef, heavyBoxes, 'heavyBox');
                animateGroup(heavySphereRef, heavySpheres, 'heavySphere');
                animateGroup(heavyGemRef, heavyGems, 'heavyGem');
            });

            useLayoutEffect(() => {
                const applyColors = (ref, dataSet) => {
                    if (ref.current) {
                        dataSet.forEach((data, i) => ref.current.setColorAt(i, data.color));
                        ref.current.instanceColor.needsUpdate = true;
                    }
                };
                applyColors(baubleRef, baubles);
                applyColors(starRef, stars);
                applyColors(heavyBoxRef, heavyBoxes);
                applyColors(heavySphereRef, heavySpheres);
                applyColors(heavyGemRef, heavyGems);
            }, []);

            return (
                <group>
                <instancedMesh ref={baubleRef} args={[undefined, undefined, baubleCount]}>
                    <sphereGeometry args={[0.8, 32, 32]} />
                    <meshStandardMaterial 
                        metalness={1.0} roughness={0.05} envMapIntensity={3.0}
                    />
                </instancedMesh>

                <instancedMesh ref={starRef} args={[undefined, undefined, starCount]}>
                    <octahedronGeometry args={[1, 0]} />
                    <meshStandardMaterial 
                        emissiveIntensity={4} toneMapped={false} color="#ffffff" emissive="#ffffff"
                    />
                </instancedMesh>

                <instancedMesh ref={heavyBoxRef} args={[undefined, undefined, heavyBoxCount]}>
                    <boxGeometry args={[1, 1, 1]} />
                    <meshStandardMaterial 
                        metalness={0.95} 
                        roughness={0.1} 
                        envMapIntensity={3.5}
                        color="#ffffff" 
                    />
                </instancedMesh>

                <instancedMesh ref={heavySphereRef} args={[undefined, undefined, heavySphereCount]}>
                    <sphereGeometry args={[0.7, 32, 32]} />
                    <meshStandardMaterial 
                        metalness={1.0} 
                        roughness={0.05} 
                        envMapIntensity={4.0}
                        color="#ffffff"
                    />
                </instancedMesh>

                <instancedMesh ref={heavyGemRef} args={[undefined, undefined, heavyGemCount]}>
                    <icosahedronGeometry args={[0.8, 0]} />
                    <meshStandardMaterial 
                        metalness={1.0} 
                        roughness={0.0} 
                        envMapIntensity={5.0}
                        flatShading={true} 
                        color="#ffffff"
                    />
                </instancedMesh>

                </group>
            );
        };

        // --- components/Scene.tsx ---
        const Scene = ({ isFormed }) => {
            const progressRef = useRef(0);
            const starRef = useRef(null);
            const starMaterialRef = useRef(null);
            const starLightRef = useRef(null);
            
            const [animProgress, setAnimProgress] = useState(0);

            const { starShape, extrudeSettings } = useMemo(() => {
                const shape = new THREE.Shape();
                const points = 5;
                const outerRadius = 0.9;
                const innerRadius = 0.45;
                
                for (let i = 0; i < points * 2; i++) {
                    const angle = (i * Math.PI) / points - Math.PI / 2;
                    const r = i % 2 === 0 ? outerRadius : innerRadius;
                    shape.lineTo(Math.cos(angle) * r, Math.sin(angle) * r);
                }
                
                const settings = {
                    depth: 0.2, 
                    bevelEnabled: false, 
                };
                
                return { starShape: shape, extrudeSettings: settings };
            }, []);

            useFrame((state, delta) => {
                const target = isFormed ? 1 : 0;
                const speed = 1.5; 
                const diff = target - progressRef.current;
                if (Math.abs(diff) > 0.001) {
                    progressRef.current += diff * speed * delta;
                    if (target === 1 && progressRef.current > 1) progressRef.current = 1;
                    if (target === 0 && progressRef.current < 0) progressRef.current = 0;
                    
                    setAnimProgress(progressRef.current);
                }

                const time = state.clock.getElapsedTime();

                if (starRef.current && isFormed) {
                    starRef.current.rotation.y -= delta * 0.5;
                    const pulse = (Math.sin(time * 5.0) + 1.0) * 0.5; 
                    const glowIntensity = 2.0 + (pulse * 4.0); 

                    if (starMaterialRef.current) {
                        starMaterialRef.current.emissiveIntensity = glowIntensity;
                    }
                    if (starLightRef.current) {
                        starLightRef.current.intensity = glowIntensity * 1.5 * progressRef.current;
                    }
                }
            });

            return (
                <React.Fragment>
                <PerspectiveCamera makeDefault position={[0, 0, 35]} fov={45} />
                <OrbitControls 
                    enablePan={false} 
                    enableZoom={true} 
                    minDistance={15} 
                    maxDistance={60}
                    autoRotate={isFormed}
                    autoRotateSpeed={0.5}
                />

                <ambientLight intensity={0.2} color="#00100d" />
                <spotLight 
                    position={[10, 40, 10]} 
                    angle={0.3} 
                    penumbra={1} 
                    intensity={2} 
                    color="#fff5cc" 
                    castShadow 
                />
                <pointLight position={[-10, -10, -10]} intensity={1} color="#004433" />
                
                <Environment preset="city" background={false} />

                <AmbientParticles />

                <group position={[0, -2, 0]}>
                    <Foliage progress={animProgress} />
                    <GoldenSpirals progress={animProgress} />
                    <Ornaments progress={animProgress} />
                    
                    <group position={[0, 9.6, 0]} scale={animProgress} ref={starRef}>
                        <mesh position={[0, 0, -0.1]}>
                            <extrudeGeometry args={[starShape, extrudeSettings]} />
                            <meshStandardMaterial 
                                ref={starMaterialRef}
                                color="#ffcf00"
                                emissive="#ffaa00"
                                emissiveIntensity={2}
                                metalness={1.0}
                                roughness={0.05}
                                envMapIntensity={3.0}
                            />
                        </mesh>
                    </group>
                    
                    <pointLight ref={starLightRef} position={[0, 9.6, 0]} intensity={0} distance={25} color="#ffaa00" />
                </group>

                <EffectComposer disableNormalPass>
                    <Bloom 
                        luminanceThreshold={0.8} 
                        mipmapBlur 
                        intensity={1.5} 
                        radius={0.6}
                    />
                    <Vignette eskil={false} offset={0.1} darkness={0.6} />
                </EffectComposer>
                </React.Fragment>
            );
        };

        // --- App.tsx ---
        function App() {
            const [treeState, setTreeState] = useState(TreeState.TREE_SHAPE);

            const toggleState = () => {
                setTreeState(prev => prev === TreeState.TREE_SHAPE ? TreeState.SCATTERED : TreeState.TREE_SHAPE);
            };

            const isFormed = treeState === TreeState.TREE_SHAPE;

            return (
                <div className="relative w-full h-screen bg-black">
                <Canvas 
                    shadows 
                    dpr={[1, 2]} 
                    gl={{ antialias: false, toneMappingExposure: 1.2 }}
                >
                    <Scene isFormed={isFormed} />
                </Canvas>

                <div className="absolute top-0 left-0 w-full h-full pointer-events-none flex flex-col justify-between px-8 pt-8 pb-8 md:px-12 md:pt-12 md:pb-12 z-10">
                    
                    <header className="flex flex-col items-center animate-fade-in-down w-full relative z-20">
                    <div className="flex items-center space-x-3 mb-1">
                        <div className="w-8 h-[1px] bg-yellow-600/70"></div>
                        <span className="text-yellow-600/90 text-xs tracking-[0.3em] font-display uppercase">Beijing 2025</span>
                        <div className="w-8 h-[1px] bg-yellow-600/70"></div>
                    </div>
                    
                    <h1 
                        className="text-6xl md:text-8xl font-script py-1 whitespace-nowrap text-center gold-shine leading-tight"
                        style={{ textShadow: '0 0 15px rgba(255, 215, 0, 0.4), 0 0 30px rgba(255, 200, 0, 0.2)' }}
                    >
                        Merry Christmas!
                    </h1>
                    
                    <p 
                        className="text-emerald-200/80 font-body italic text-lg tracking-wide text-center mt-[-0.5rem] md:mt-[-1rem]"
                        style={{ textShadow: '0 0 10px rgba(50, 255, 120, 0.4), 0 0 20px rgba(50, 255, 120, 0.2)' }}
                    >
                        Big Baby · Good Baby · Small Baby
                    </p>
                    </header>

                    <div className="pointer-events-auto flex flex-col items-center space-y-6 pb-4 md:pb-8">
                    <button 
                        onClick={toggleState}
                        className={`
                            group relative px-12 py-4 overflow-hidden rounded-sm transition-all duration-500 ease-out
                            ${isFormed 
                                ? 'bg-transparent border border-yellow-600/30 hover:border-yellow-500/80' 
                                : 'bg-yellow-900/20 border border-yellow-500/50 hover:bg-yellow-900/40'}
                        `}
                    >
                        <div className="absolute inset-0 w-full h-full bg-gradient-to-r from-transparent via-yellow-500/10 to-transparent translate-x-[-100%] group-hover:translate-x-[100%] transition-transform duration-1000"></div>
                        
                        <span className={`
                            relative font-display tracking-[0.2em] text-sm md:text-base uppercase transition-colors duration-300
                            ${isFormed ? 'text-yellow-100' : 'text-yellow-300'}
                        `}>
                            {isFormed ? 'Scatter Elements' : 'Assemble Tree'}
                        </span>
                    </button>

                    <div className="flex space-x-8 text-emerald-800/60 text-xs font-display tracking-widest uppercase">
                        <span>75,000 Particles</span>
                        <span>•</span>
                        <span>Real-time Physics</span>
                        <span>•</span>
                        <span>Raytraced Glow</span>
                    </div>
                    </div>

                    <div className="absolute top-0 left-0 p-8 opacity-30">
                        <div className="w-32 h-[1px] bg-gradient-to-r from-yellow-600 to-transparent"></div>
                        <div className="w-[1px] h-32 bg-gradient-to-b from-yellow-600 to-transparent"></div>
                    </div>
                    <div className="absolute bottom-0 right-0 p-8 opacity-30 transform rotate-180">
                        <div className="w-32 h-[1px] bg-gradient-to-r from-yellow-600 to-transparent"></div>
                        <div className="w-[1px] h-32 bg-gradient-to-b from-yellow-600 to-transparent"></div>
                    </div>

                </div>
                </div>
            );
        }

        // --- index.tsx ---
        const rootElement = document.getElementById('root');
        if (!rootElement) {
            throw new Error("Could not find root element to mount to");
        }

        const root = ReactDOM.createRoot(rootElement);
        root.render(
            <App />
        );
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>